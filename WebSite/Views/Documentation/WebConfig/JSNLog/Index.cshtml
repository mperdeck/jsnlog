@using ViewExtensions

@{
    ViewBag.Title = "<jsnlog> Element";
    ViewBag.Key = "webconfig-jsnlog";
    ViewBag.Description = "The root element for all JSNLog configuration elements.";
    Layout = "~/Views/Shared/_ElementLayout.cshtml";
    ViewBag.VersionNameRegex = "NetJs";
}

@section Definition {
<pre>&lt;configuration&gt; 
    &lt;jsnlog
        enabled="true|false"
        maxMessages="number"
        defaultAjaxUrl="string"
        serverSideLogger="string"
        serverSideLevel="number|TRACE|DEBUG|INFO|WARN|ERROR|FATAL" 
        serverSideMessageFormat="string"
        productionLibraryPath="string" &gt;
    &lt;/jsnlog&gt;
&lt;/configuration&gt; 
</pre>
}

@section Remarks {
    <p>
        The &lt;jsnlog&gt; element can have the following attributes:
    </p>

    <table class="table wide">
        @Html.Partial("_OptionsTableHeading", new ViewDataDictionary {
            { "configSource", "web.config"}
        })
        <tbody>
            @Html.TableRowHtml("enabled", "optional", "true",
            @"If false, all loggers are disabled.")
            @Html.TableRowHtml("maxMessages", "optional", "no maximum", "Limits total number of messages sent to the server. See remarks below.")
            @Html.TableRowHtml("defaultAjaxUrl", "optional", "see remarks", "Default url used by ajax appenders when no url is set. See remarks below.")
            @Html.TableRowHtml("serverSideLogger", "optional", "(empty)",
            @"By default, all log messages from your JavaScript code are passed on to your server side logging package
with the name of the JavaScript logger.
<p/>
However, if you want to use a specific logger name for all your JavaScript log messages, you can specify that with this attribute.")
            @Html.TableRowHtml("serverSideLevel", "optional", "(empty)",
            @"By default, all log messages from your JavaScript code are passed on to your server side logging package with the same level as the original JavaScript log message.
<p/>
However, if you want to use a specific level, you can specify that with this attribute.")
            @Html.TableRowHtml("serverSideMessageFormat", "optional", "%message",
            @"See remarks.")
            @Html.TableRowHtml("productionLibraryPath", "optional", "(empty)",
            @"Path to the jsnlog.js file. JSNLog generates a &lt;script&gt; tag with this url.
<p/>
If you do not specify this, JSNLog will not generate the &lt;script&gt; tag.
This makes sense if you for example combine jsnlog.js with your other
JavaScript files and you use your own &lt;script&gt; tag to load this combined file.")
        </tbody>
    </table>

    @Html.Partial("_DefaultAjaxUrlRemarks", new ViewDataDictionary {
        { "configSource", "web.config"},
    })

    @Html.Partial("_MaxMessagesRemarks", new ViewDataDictionary {
        { "configSource", "web.config"},
    })

    <h3>serverSideMessageFormat</h3>

    <p>
        Your server not only receives the the original message passed into the JavaScript logger,
        but also the logger, the level, a timestamp, etc.
    </p>
    <p>
        You can choose to have this additional information logged on the server along with
        the original message, by setting <span class="term">serverSideMessageFormat</span> to a format string with
        one or more place holders:
    </p>

    <table class="table wide">
        <thead>
            <tr>
                <th>Place holder</th>
                <th>Is replaced by</th>
            </tr>
        </thead>
        <tbody>
            <tr valign="top">
                <td>%message</td>
                <td>Original message given to the JavaScript logger</td>
            </tr>
            <tr valign="top">
                <td>%jsonmessage</td>
                <td>Original message given to the JavaScript logger, as a valid JSON value. See below.</td>
            </tr>
            <tr valign="top">
                <td>%utcDate</td>
                <td>Date and time in UTC when the message was generated, according to the client's clock</td>
            </tr>
            <tr valign="top">
                <td>%utcDateServer</td>
                <td>Date and time in UTC when the message was received by the server, according to the server's clock</td>
            </tr>
            <tr valign="top">
                <td>%date</td>
                <td>
                    Date and time when the message was generated, according to the client's clock.
                    This equals %utcDate converted to the server's local time.
                </td>
            </tr>
            <tr valign="top">
                <td>%dateServer</td>
                <td>Date and time in the server's local time when the message was received by the server, according to the server's clock</td>
            </tr>
            <tr valign="top">
                <td>%level</td>
                <td>Level of the message, as provided by the JavaScript code</td>
            </tr>
            <tr valign="top">
                <td>%userAgent</td>
                <td>Identifies the make of the browser</td>
            </tr>
            <tr valign="top">
                <td>%userHostAddress</td>
                <td>IP address of the sender</td>
            </tr>
            <tr valign="top">
                <td>%url</td>
                <td>Url of the page on which the message was generated</td>
            </tr>
            <tr valign="top">
                <td>%logger</td>
                <td>JavaScript logger that generated the message</td>
            </tr>
            <tr valign="top">
                <td>%requestId</td>
                <td>
                    Identifies the request for which the log message was created.
                    <p />
                    If you configure your JavaScript
                    loggers in web.config, this request id will be generated for you. Otherwise, set this request id
                    using the
                    @Html.ViewLink("jsnlogjs-jl-setOptions", "JL.setOptions")
                    method.
                </td>
            </tr>
            <tr valign="top">
                <td>%newline*</td>
                <td>Newline character</td>
            </tr>
        </tbody>
    </table>
    *<small> If you use Elmah, %newline won't result in a newline in the elmah.axd page, because Elmah doesn't convert line breaks in log messages to HTML &lt;br /&gt; tags.</small>

    <h4>%message and %jsonmessage</h4>

    <p>
        Most people store log messages as unstructured strings of text. If that is you, you can skip this section.
        However, if you store log messages as valid JSON objects, read on.
    </p>

    <p>
        Both <span class="term">%message</span> and <span class="term">%jsonmessage</span> are replaced by a string that represents the message that was logged.
        The difference is that whereas <span class="term">%message</span> is replaced the log message as-is, 
        <span class="term">%jsonmessage</span> is replaced by a string that can be used in a JSON message.
    </p>
    <p>
        To clarify the issue, see the table below:
    </p>
    <table class="table">
        <tr valign="top">
            <th>JavaScript</th>
            <th>%message</th>
            <th>%jsonmessage</th>
        </tr>
        <tr valign="top">
            <td>
                JL().error("O'Connell");
            </td>
            <td>
                O'Connell
            </td>
            <td>
                "O\u0027Connell"
            </td>
        </tr>
        <tr valign="top">
            <td>
                JL().error({"f1": "v1", "f2": "v2"});
            </td>
            <td>
                {"f1": "v1", "f2": "v2"}
            </td>
            <td>
                {"f1": "v1", "f2": "v2"}
            </td>
        </tr>
    </table>
    <p>
        As you see, there is no difference when logging an object (in the second row). But when logging a simple string,
        <span class="term">%message</span> is replaced by the string, while
        for <span class="term">%jsonmessage</span> the string is escaped and quoted.
    </p>
    <p>
        This is important if you want to write valid JSON strings to your log. Suppose you attempted to do that using:
    </p>
    <pre>serverSideMessageFormat=&quot;{ 'Message': %message }&quot;</pre>
    <p>
        That would work well if you only logged objects. But if you logged the string <span class="term">O'Connell</span>, that would result in:
    </p>
    <pre>{ 'Message': O'Connell }</pre>
    <p>
        Which is not a valid JSON string. However, if you'd use:
    </p>
    <pre>serverSideMessageFormat=&quot;{ 'Message': <span class="addedcode">%jsonmessage</span> }&quot;</pre>
    <p>
        The result would be a valid JSON string:
    </p>
    <pre>{ 'Message': "O\u0027Connell" }</pre>

    <h4>serverSideMessageFormat and structured logging</h4>
    <p>
        If you create structured logs using
        <a href="http://serilog.net/" target="_blank">Serilog</a>,
        make sure that your format string results in a valid JSON string. Otherwise it will be logged as a string rather than an object.
    </p>
    <p>
        Take for example:
    </p>
<pre>serverSideMessageFormat=&quot;Sent: %date, Browser: %userAgent, Message: %message&quot;</pre>
    <p>
        This will result in a string such as this in your log:
    </p>
    <pre>"{ 'Sent': 2014-08-19 21:02:42,603, 'Browser': 'Mozilla/5.0 ...', 'Message': {\"x\":5,\"y\":88} }"</pre>
    <p>
        To get a structured object instead, make sure that the result of your format string is a valid JSON string. For example:
    </p>
    <pre>serverSideMessageFormat=&quot;<span class="addedcode">{ '</span>Sent<span class="addedcode">'</span>: <span class="addedcode">'</span>%date<span class="addedcode">'</span>, <span class="addedcode">'</span>Browser<span class="addedcode">'</span>: <span class="addedcode">'</span>%userAgent<span class="addedcode">'</span>, <span class="addedcode">'</span>Message<span class="addedcode">'</span>: <span class="addedcode">%jsonmessage</span> <span class="addedcode">}</span>&quot;</pre>
    <p>
        Note:
    </p>
    <ul>
        <li>
            The curly braces;
        </li>
        <li>
            Field names have been quoted.
        </li>
        <li>
            <span class="term">%date</span> and <span class="term">%userAgent</span> have been quoted as well, to make them strings.
        </li>
        <li>
            <span class="term">%message</span> has been replaced by <span class="term">%jsonmessage</span>, which has not been quoted. 
            That way, when you log objects, they will be logged as objects rather than strings.
        </li>
    </ul>
    <p>
        This will result in an object such as this in your log:
    </p>
    <pre>{ "Sent" : "2014-08-19 21:02:42,603", "Browser" : "Mozilla/5.0 ...", "Message" : { "x" : 5, "y" : 88 } }</pre>

    <p>
        Finally, the default value of
        <span class="term">serverSideMessageFormat</span>
        gives you structured logging out of the box, 
        even though the default is <span class="term">%message</span>. 
        The reason is that the Serilog adapter that is used by JSNLog to log to Serilog
        regards all strings that are not valid JSON strings as simple strings that are to be logged as-is.
    </p>
}

@section Examples {
    <p>
        This shows the date and time that the log message was created on the client as well as the user agent
        in each log message.
    </p>
<pre>&lt;jsnlog serverSideMessageFormat="Sent: %date, Brower: %userAgent - %message" &gt;</pre>

    <p>
        This processes all client side JavaScript log messages via the server side logger "jslogger".
    </p>
    <pre>&lt;jsnlog serverSideLogger="jslogger"&gt;</pre>

    <p>
        This disables all JavaScript loggers.
    </p>
    <pre>&lt;jsnlog enabled="false"&gt;</pre>


}





